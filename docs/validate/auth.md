# 权限验证

>&nbsp;权限验证想要做到体验好，有1点基础：就是要立刻生效。那么就要保证每次信息的请求，系统都要去取拿到最新的权限设置数据来校验，从而保证“权限的立即”生效的体验。而权限的数据是放在数据
库中的，那么想保证每一条请求，每一个`websocket`消息都是在通过权限验证的前提下。那数据库的处理速度将会大打折扣，系统的处理速度下降，这将拖累整个应用的体验。  
  &nbsp;所以这里引用了
`redis`缓存机制，既每个登入的成员的权限查询规则都在放在`redis`，由`redis`向整个应用的成员提供最新的权限规则。所有每次的权限的变更如成员锁定等，在保存到`mysql`的同时，也要把新的数据推送到`redis`
保障权限验证的`即时性`。 

# 缓存格式
>&nbsp;缓存的数据键名采用`member_`+`token`命名，类型是`hash`，而这个而这个`token`所拥有的权限规则`json`序列化后保存在属性名`rules`格式如下：
``` PHP
  member_d9453d803ffd3b25f12f4ed6242de03a => rules    : "{'aip/V1.Role/group',
                                                          'api/V1.Role/getallgroup'
                                                          ...
                                                         }",
                                             account  :"wuchuheng",
                                             email    :"wuchuheng@163.com",
                                             username :"吴楚衡",
                                             ...
```
!>提示下啊!  
这里保存的数据类型为什么不把所有的数据数据序列化字符串，直接保存，而要用`hash`再加`json`序列化来保存？这是因为，`PHP`在解析`json`序列时,
`json`越长,性能越差，虽然解析一个长点`json`可能要1微秒，但如果有1000人同时在线，同时发送`websocket`消息，那就要并行解析1000次`json`,
没有1秒延迟这么夸大，但量化到质化还是有的，体验的差距
也就越加明显，所以这里用`hash`来缩短`json`的长度,提高性能。


# 缓存的更新
>&nbsp;整个权限控制用了4张表，`member`(用户表)=>`auth_group_access`(用户关联权限组表)=>`auth_group`(权限分组表)=>`auth_rule`(权限表)。
  后台能让用户修改到跟权限有关系的功能就2种。一是为一个用户重新选择另一个权限组，底层修改的是`auth_group_access`;另一个功能是为一个权限组的权限集合
  新增或者减去一条规则，底层修改的是`auth_group`表。所以从数据库的角度来看， 一旦这2个表发生修改，就要更新缓存了(换言之，后台用户能操作的跟权限有关的也就这2张表了)。从而保障了权限验证的实时性。




